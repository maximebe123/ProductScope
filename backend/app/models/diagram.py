from typing import List, Optional, Literal
from pydantic import BaseModel, Field
from enum import Enum  # Keep for HandlePosition

# Import from centralized node registry (single source of truth)
from app.core.ai.node_registry import (
    CategoryId,
    NodeTypeId,
    NODE_TYPE_LAYERS,
)


class HandlePosition(str, Enum):
    """Edge connection handle positions"""
    TOP = "top"
    BOTTOM = "bottom"
    LEFT = "left"
    RIGHT = "right"


class VolumeAttachment(BaseModel):
    """Volume mount configuration for nodes"""
    name: str = Field(..., description="Volume name")
    mountPath: str = Field(..., description="Mount path in container")


class NodeData(BaseModel):
    """Data payload for a node"""
    label: str = Field(..., description="Display label for the node")
    nodeType: NodeTypeId = Field(..., description="Type of node from available categories")
    tags: Optional[List[str]] = Field(default=[], description="Optional tags for the node")
    volumes: Optional[List[VolumeAttachment]] = Field(default=[], description="Volume attachments")
    isGroup: Optional[bool] = Field(default=False, description="Whether this is a group node")


class GeneratedNode(BaseModel):
    """A node generated by the AI with logical positioning hints"""
    id: str = Field(..., description="Unique node identifier (format: node_0, node_1, etc.)")
    type: Literal["customNode", "groupNode"] = Field(
        default="customNode",
        description="Node component type"
    )
    data: NodeData = Field(..., description="Node data payload")
    logicalLayer: int = Field(
        ...,
        ge=0,
        le=10,
        description="Logical layer for positioning (0=external, 1=frontend, 2=integration, 3=services, 4=data/messaging, 5=observability)"
    )
    logicalOrder: int = Field(
        ...,
        ge=0,
        description="Order within the layer (left to right, starting at 0)"
    )
    parentGroup: Optional[str] = Field(
        default=None,
        description="Parent group ID if this node is nested inside a group"
    )


class EdgeData(BaseModel):
    """Data payload for an edge"""
    label: Optional[str] = Field(default=None, description="Optional label for the edge")
    colorFromTarget: Optional[bool] = Field(
        default=False,
        description="Use target node color instead of source"
    )


class GeneratedEdge(BaseModel):
    """A connection between two nodes"""
    id: str = Field(..., description="Unique edge identifier (format: edge_0, edge_1, etc.)")
    source: str = Field(..., description="Source node ID")
    target: str = Field(..., description="Target node ID")
    sourceHandle: Optional[HandlePosition] = Field(
        default=None,
        description="Connection point on source node"
    )
    targetHandle: Optional[HandlePosition] = Field(
        default=None,
        description="Connection point on target node"
    )
    data: Optional[EdgeData] = Field(default=None, description="Edge data payload")


class DiagramDescription(BaseModel):
    """High-level description of the generated architecture"""
    title: str = Field(..., description="Diagram title")
    summary: str = Field(..., description="Brief summary of the architecture (1-2 sentences)")
    components: List[str] = Field(..., description="List of main component names")


class GeneratedDiagram(BaseModel):
    """Complete diagram structure generated by the AI"""
    description: DiagramDescription = Field(..., description="High-level diagram description")
    nodes: List[GeneratedNode] = Field(..., description="All nodes in the diagram")
    edges: List[GeneratedEdge] = Field(..., description="All connections between nodes")


# NODE_TYPE_LAYERS is imported from node_registry (single source of truth)
# Re-exported here for backward compatibility:
# from app.models.diagram import NODE_TYPE_LAYERS
__all__ = ["CategoryId", "NodeTypeId", "NODE_TYPE_LAYERS", "HandlePosition",
           "VolumeAttachment", "NodeData", "GeneratedNode", "EdgeData",
           "GeneratedEdge", "DiagramDescription", "GeneratedDiagram"]
